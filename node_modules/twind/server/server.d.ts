import { PropertiesFallback, PropertiesHyphenFallback } from 'csstype';

interface CSSCustomProperties {
    '--tw-rotate'?: string;
    '--tw-gradient-stops'?: string;
}
interface CSSProperties extends PropertiesFallback<string, string>, PropertiesHyphenFallback<string, string>, CSSCustomProperties {
}

declare type Falsy = '' | 0 | -0 | false | null | undefined | void;
declare type MaybeArray<T> = T | readonly T[];

interface TWCallable {
    (strings: TemplateStringsArray, ...interpolations: Token[]): string;
    (...tokens: Token[]): string;
}
interface TW extends TWCallable {
    theme: ThemeResolver;
}
interface Context {
    /** Allow composition */
    readonly tw: TWCallable;
    /** Access to theme values */
    readonly theme: ThemeResolver;
    /** Create unique identifier (group, custom properties) */
    readonly tag: (key: string) => string;
    readonly css: (rule: Rule[] | string) => CSSRules;
}
interface Sheet<T = unknown> {
    readonly target: T;
    insert: (rule: string, index: number) => void;
    init?: SheetInit;
}
declare type SheetInitCallback<T = unknown> = (value?: T | undefined) => T;
interface SheetInit {
    /**
     * Register a function that should be called to use a snapshot state or create a new state.
     */
    <T>(callback: SheetInitCallback<T>): T;
}
interface Rule {
    /**
     * The variants: `[":sm", ":dark", ":hover"]`
     */
    v: string[];
    /**
     * The directive: `"text-sm"`, `"rotate-45"`
     */
    d: string | InlineDirective;
    /** Is this rule negated: `"-rotate-45"` =\> `true` */
    n: boolean | undefined;
    /** Is this rule marked as important: `"stroke-4!"` =\> `true` */
    i: boolean | undefined;
    /**
     * The id is the tailwind rule including variants, negate and directive
     *
     * Initialy this is set to an empty string.
     *
     * This is used to cache the id of static rules (from template literals).
     */
    $: string;
}
interface InlineDirective {
    (context: Context): CSSRules | string | Falsy | TypescriptCompat;
}
interface TokenGrouping extends Record<string, Token> {
}
declare type TypescriptCompat = boolean | number;
declare type Token = string | TokenGrouping | InlineDirective | Token[] | Falsy | TypescriptCompat;
declare type CSSAtMedia = Record<string, CSSRules>;
declare type CSSAtSupports = Record<string, CSSRules>;
declare type CSSAtKeyframes = Record<string, CSSProperties | ((context: Context) => CSSProperties)>;
/**
 * See: https://drafts.csswg.org/css-nesting/#nest-selector
 *
 * ```
 * "& > * + *": {
 *   marginLeft: 16
 * },
 *
 * // In a comma-separated list, each individual selector shall start with "&"
 * "&:focus, &:active": {
 *   outline: "solid"
 * },
 *
 * // Self-references are also supported
 * "& + &": {
 *   color: "green"
 * }
 * ```
 */
interface CSSRules {
    /** Global defaults */
    '@apply'?: MaybeArray<string | Falsy | TypescriptCompat>;
    global?: CSSRules | CSSRulesThunk;
    [key: string]: CSSProperties | CSSAtMedia | CSSAtSupports | CSSAtKeyframes | CSSRules | MaybeArray<string | Falsy | TypescriptCompat> | CSSRulesThunk;
}
interface CSSRulesThunk {
    (context: Context): CSSProperties | CSSAtMedia | CSSAtSupports | CSSAtKeyframes | CSSRules | CSSRulesThunk | MaybeArray<string | Falsy | TypescriptCompat>;
}

interface ThemeResolver {
    <Section extends keyof Theme>(section: Section): Record<string, ThemeSectionType<Theme[Section]>>;
    <Section extends keyof Theme>(keypath: `${Section}.${string}`): ThemeSectionType<Theme[Section]> | undefined;
    <Section extends keyof Theme>(keypath: `${Section}.${string}`, defaultValue: NonNullable<ThemeSectionType<Theme[Section]>>): NonNullable<ThemeSectionType<Theme[Section]>>;
    <Section extends keyof Theme>(section: Section, key: string | string[]): ThemeSectionType<Theme[Section]> | undefined;
    <Section extends keyof Theme>(section: Section, key: string | string[], defaultValue: NonNullable<ThemeSectionType<Theme[Section]>>): NonNullable<ThemeSectionType<Theme[Section]>>;
}
declare type Unwrap<T> = T extends string[] ? string : T extends Record<string, infer R> ? R : T;
declare type ThemeSectionType<T> = T extends ThemeSection<infer R> ? Unwrap<R> : Exclude<T, ThemeSectionResolver<T>>;
interface ThemeSectionResolverContext {
    /**
     * No-op function as negated values are automatically infered and do _not_ not to be in the theme.
     */
    readonly negative: (records: Record<string, string | undefined>) => Record<string, string | undefined>;
    readonly breakpoints: (records: Record<string, ThemeScreen | undefined>) => Record<string, string | undefined>;
}
declare type ThemeSectionRecord<T = string> = Record<string, T | undefined>;
declare type ThemeSectionResolver<T = string> = (theme: ThemeResolver, context: ThemeSectionResolverContext) => ThemeSectionRecord<T>;
declare type ThemeSection<T = string> = ThemeSectionRecord<T> | ThemeSectionResolver<T>;
interface ThemeContainer {
    screens?: Record<string, string | undefined>;
    center?: boolean;
    padding?: string | Record<string, string | undefined>;
}
declare type ThemeScreenValue = string | {
    raw: string;
} | {
    min: string;
    max?: string;
} | {
    min?: string;
    max: string;
};
declare type ThemeScreen = MaybeArray<ThemeScreenValue>;
interface ThemeColorObject extends Record<string, ThemeColor> {
}
declare type ThemeColor = string | ThemeColorObject;
declare type ThemeFontSize = string | [size: string, lineHeight: string] | [size: string, options: {
    lineHeight?: string;
    letterSpacing?: string;
}];
declare type ThemeOutline = [outline: string, offset: string];
interface Theme {
    colors: ThemeSection<ThemeColor>;
    spacing: ThemeSection;
    durations: ThemeSection<string | string[]>;
    screens: ThemeSection<ThemeScreen>;
    animation: ThemeSection<string | string[]>;
    backgroundColor: ThemeSection<ThemeColor>;
    backgroundImage: ThemeSection<string | string[]>;
    backgroundOpacity: ThemeSection;
    borderColor: ThemeSection<ThemeColor>;
    borderOpacity: ThemeSection;
    borderRadius: ThemeSection;
    borderWidth: ThemeSection;
    boxShadow: ThemeSection<string | string[]>;
    container: ThemeContainer | ThemeSectionResolver<ThemeContainer>;
    divideColor: ThemeSection<ThemeColor>;
    divideOpacity: ThemeSection;
    divideWidth: ThemeSection;
    fill: ThemeSection<ThemeColor>;
    flex: ThemeSection;
    fontFamily: ThemeSection<string | string[]>;
    fontSize: ThemeSection<ThemeFontSize>;
    fontWeight: ThemeSection;
    gap: ThemeSection;
    gradientColorStops: ThemeSection<ThemeColor>;
    height: ThemeSection;
    inset: ThemeSection;
    keyframes: ThemeSection<Record<string, CSSProperties>>;
    letterSpacing: ThemeSection;
    lineHeight: ThemeSection;
    margin: ThemeSection;
    maxHeight: ThemeSection;
    maxWidth: ThemeSection;
    minHeight: ThemeSection;
    minWidth: ThemeSection;
    opacity: ThemeSection;
    order: ThemeSection;
    outline: ThemeSection<ThemeOutline>;
    padding: ThemeSection;
    placeholderColor: ThemeSection<ThemeColor>;
    placeholderOpacity: ThemeSection;
    ringColor: ThemeSection<ThemeColor>;
    ringOffsetColor: ThemeSection<ThemeColor>;
    ringOffsetWidth: ThemeSection;
    ringOpacity: ThemeSection;
    ringWidth: ThemeSection;
    rotate: ThemeSection;
    scale: ThemeSection;
    skew: ThemeSection;
    space: ThemeSection;
    stroke: ThemeSection<ThemeColor>;
    strokeWidth: ThemeSection;
    textColor: ThemeSection<ThemeColor>;
    textOpacity: ThemeSection;
    transitionDelay: ThemeSection<string | string[]>;
    transitionDuration: ThemeSection<string | string[]>;
    transitionProperty: ThemeSection<string | string[]>;
    transitionTimingFunction: ThemeSection<string | string[]>;
    translate: ThemeSection;
    width: ThemeSection;
    zIndex: ThemeSection;
}

/**
 * [[include:src/sheets/README.md]]
 *
 * @packageDocumentation
 * @module twind/sheets
 */

/**
 * Allows to reset and snaphot the current state of an sheet and
 * in extension the internal mutable state (caches, ...) of `tw`.
 */
interface Storage {
    /**
     * Register a function that should be called to create a new state.
     */
    init: SheetInit;
    /**
     * Creates a snapshot of the current state, invokes all init callbacks to create a fresh state
     * and returns the snaphot.
     */
    reset: (snapshot?: unknown[] | undefined) => unknown[];
}
/**
 * A sheet that collects styles into an array.
 */
interface VirtualSheet extends Sheet<string[]>, Storage {
    init: SheetInit;
}
/**
 * Creates an sheet which collects style rules into an array.
 */
declare const virtualSheet: () => VirtualSheet;
interface StyleTagProperties {
    id: string;
    textContent: string;
}
interface HasTarget {
    readonly target: readonly string[];
}
declare type StyleTagSheet = HasTarget | readonly string[];
/**
 * Transforms css rules into `<style>` tag properties.
 */
declare const getStyleTagProperties: (sheet: StyleTagSheet) => StyleTagProperties;
/**
 * Transforms css rules into a `<style>` tag string.
 */
declare const getStyleTag: (sheet: StyleTagSheet, attributes?: Record<string, string> | undefined) => string;

/**
 * [[include:src/shim/server/README.md]]
 *
 * @packageDocumentation
 * @module twind/shim/server
 */

/**
 * Options for {@link shim}.
 */
interface ShimOptions {
    /**
     * Custom {@link twind.tw | tw} instance to use (default: {@link twind.tw}).
     */
    tw?: TW;
}

/**
 * Shim the passed html.
 *
 * 1. tokenize the markup and process element classes with either the
 *    {@link twind.tw | default/global tw} instance or a {@link ShimOptions.tw | custom} instance
 * 2. populate the provided sheet with the generated rules
 * 3. output the HTML markup with the final element classes

 * @param markup the html to shim
 * @param options to use
 * @return the HTML markup with the final element classes
 */
declare const shim: (markup: string, options?: TW | ShimOptions) => string;

interface AsyncVirtualSheet extends Sheet {
    readonly target: readonly string[];
    init: SheetInit;
    reset: () => void;
    enable: () => void;
    disable: () => void;
}
declare const asyncVirtualSheet: () => AsyncVirtualSheet;

export { AsyncVirtualSheet, Storage, StyleTagProperties, StyleTagSheet, VirtualSheet, asyncVirtualSheet, getStyleTag, getStyleTagProperties, shim, virtualSheet };
//# sourceMappingURL=server.d.ts.map
