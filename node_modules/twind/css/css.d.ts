import { PropertiesFallback, PropertiesHyphenFallback } from 'csstype';

interface CSSCustomProperties {
    '--tw-rotate'?: string;
    '--tw-gradient-stops'?: string;
}
interface CSSProperties extends PropertiesFallback<string, string>, PropertiesHyphenFallback<string, string>, CSSCustomProperties {
}

declare type Falsy = '' | 0 | -0 | false | null | undefined | void;
declare type MaybeArray<T> = T | readonly T[];

interface TWCallable {
    (strings: TemplateStringsArray, ...interpolations: Token[]): string;
    (...tokens: Token[]): string;
}
interface TW extends TWCallable {
    theme: ThemeResolver;
}
interface Context {
    /** Allow composition */
    readonly tw: TWCallable;
    /** Access to theme values */
    readonly theme: ThemeResolver;
    /** Create unique identifier (group, custom properties) */
    readonly tag: (key: string) => string;
    readonly css: (rule: Rule[] | string) => CSSRules;
}
declare type MaybeThunk<T> = T | ((context: Context) => T);
interface Preflight {
    (preflight: CSSRules, context: Context): MaybeThunk<CSSRules | undefined | void>;
}
interface ThemeConfiguration extends Partial<Theme> {
    extend?: Partial<Theme>;
}
interface Sheet<T = unknown> {
    readonly target: T;
    insert: (rule: string, index: number) => void;
    init?: SheetInit;
}
declare type SheetInitCallback<T = unknown> = (value?: T | undefined) => T;
interface SheetInit {
    /**
     * Register a function that should be called to use a snapshot state or create a new state.
     */
    <T>(callback: SheetInitCallback<T>): T;
}
declare type Prefixer = (property: string, value: string, important?: boolean) => string;
declare type Hasher = (value: string) => string;
declare type DarkMode = 'media' | 'class' | false;
interface Configuration {
    /**
     * Determines the dark mode strategy (default: `"media"`).
     */
    darkMode?: DarkMode;
    theme?: ThemeConfiguration;
    plugins?: Plugins;
    /**
     * ```js
     * {
     *   ':new-variant': '& .selector',
     * }
     * ```
     */
    variants?: Record<string, string>;
    /**
     * Sets a cryptographic nonce (number used once) on the enclosing `<style>` tag when generating a page on demand.
     *
     * Useful for enforcing a [Content Security Policy (CSP)](https://developer.mozilla.org/docs/Web/HTTP/CSP).
     */
    nonce?: string;
    /** Style insertion methodology to be used. */
    sheet?: Sheet;
    /** Called right before the first rule is injected. */
    preflight?: Preflight | boolean | CSSRules;
    /** Auto-prefixer method for CSS propertyâ€“value pairs. */
    prefix?: Prefixer | boolean;
    hash?: Hasher | boolean;
    mode?: Mode | 'strict' | 'warn' | 'silent';
}
declare type ReportInfo = {
    id: 'LATE_SETUP_CALL';
} | {
    id: 'UNKNOWN_DIRECTIVE';
    rule: string;
} | {
    id: 'UNKNOWN_THEME_VALUE';
    key: string | undefined;
} | {
    id: 'INJECT_CSS_ERROR';
    error: Error;
    css: string;
};
interface Mode {
    /** Called for unknown theme values */
    unknown: <Section extends keyof Theme>(section: Section, key: string[] | undefined, optional: boolean, context: Context) => ThemeSectionType<Theme[Section]> | undefined | void;
    /**
     * Notify error (missing plugin, duplicate directives? )
     *
     * Why id?
     * - can generate an url with more info
     * - reduce bundle size by omitting large error messages
     */
    report(info: ReportInfo, context: Context): void;
}
declare type Plugin = string | CSSRules | DirectiveHandler;
declare type Plugins = Record<string, Plugin | undefined>;
interface DirectiveHandler {
    /**
     * Creates CSSRules based on `parameters`
     */
    (parameters: string[], context: Context, id: string): InlineDirective | CSSRules | string | Falsy;
}
interface Rule {
    /**
     * The variants: `[":sm", ":dark", ":hover"]`
     */
    v: string[];
    /**
     * The directive: `"text-sm"`, `"rotate-45"`
     */
    d: string | InlineDirective;
    /** Is this rule negated: `"-rotate-45"` =\> `true` */
    n: boolean | undefined;
    /** Is this rule marked as important: `"stroke-4!"` =\> `true` */
    i: boolean | undefined;
    /**
     * The id is the tailwind rule including variants, negate and directive
     *
     * Initialy this is set to an empty string.
     *
     * This is used to cache the id of static rules (from template literals).
     */
    $: string;
}
interface Directive<T> {
    /** Can be used as a inline directive */
    (context: Context): T;
    /** Can be used as a plugin */
    (params: string[], context: Context): T;
}
interface InlineDirective {
    (context: Context): CSSRules | string | Falsy | TypescriptCompat;
}
interface TokenGrouping extends Record<string, Token> {
}
declare type TypescriptCompat = boolean | number;
declare type Token = string | TokenGrouping | InlineDirective | Token[] | Falsy | TypescriptCompat;
declare type CSSAtMedia = Record<string, CSSRules>;
declare type CSSAtSupports = Record<string, CSSRules>;
declare type CSSAtKeyframes = Record<string, CSSProperties | ((context: Context) => CSSProperties)>;
/**
 * See: https://drafts.csswg.org/css-nesting/#nest-selector
 *
 * ```
 * "& > * + *": {
 *   marginLeft: 16
 * },
 *
 * // In a comma-separated list, each individual selector shall start with "&"
 * "&:focus, &:active": {
 *   outline: "solid"
 * },
 *
 * // Self-references are also supported
 * "& + &": {
 *   color: "green"
 * }
 * ```
 */
interface CSSRules {
    /** Global defaults */
    '@apply'?: MaybeArray<string | Falsy | TypescriptCompat>;
    global?: CSSRules | CSSRulesThunk;
    [key: string]: CSSProperties | CSSAtMedia | CSSAtSupports | CSSAtKeyframes | CSSRules | MaybeArray<string | Falsy | TypescriptCompat> | CSSRulesThunk;
}
interface CSSRulesThunk {
    (context: Context): CSSProperties | CSSAtMedia | CSSAtSupports | CSSAtKeyframes | CSSRules | CSSRulesThunk | MaybeArray<string | Falsy | TypescriptCompat>;
}

interface ThemeResolver {
    <Section extends keyof Theme>(section: Section): Record<string, ThemeSectionType<Theme[Section]>>;
    <Section extends keyof Theme>(keypath: `${Section}.${string}`): ThemeSectionType<Theme[Section]> | undefined;
    <Section extends keyof Theme>(keypath: `${Section}.${string}`, defaultValue: NonNullable<ThemeSectionType<Theme[Section]>>): NonNullable<ThemeSectionType<Theme[Section]>>;
    <Section extends keyof Theme>(section: Section, key: string | string[]): ThemeSectionType<Theme[Section]> | undefined;
    <Section extends keyof Theme>(section: Section, key: string | string[], defaultValue: NonNullable<ThemeSectionType<Theme[Section]>>): NonNullable<ThemeSectionType<Theme[Section]>>;
}
interface ThemeHelper {
    <Section extends keyof Theme>(section: Section): (context: Context) => Record<string, ThemeSectionType<Theme[Section]>>;
    <Section extends keyof Theme>(keypath: `${Section}.${string}`): (context: Context) => ThemeSectionType<Theme[Section]> | undefined;
    <Section extends keyof Theme>(keypath: `${Section}.${string}`, defaultValue: NonNullable<ThemeSectionType<Theme[Section]>>): (context: Context) => NonNullable<ThemeSectionType<Theme[Section]>>;
    <Section extends keyof Theme>(section: Section, key: string | string[]): (context: Context) => ThemeSectionType<Theme[Section]> | undefined;
    <Section extends keyof Theme>(section: Section, key: string | string[], defaultValue: NonNullable<ThemeSectionType<Theme[Section]>>): (context: Context) => NonNullable<ThemeSectionType<Theme[Section]>>;
}
declare type Unwrap<T> = T extends string[] ? string : T extends Record<string, infer R> ? R : T;
declare type ThemeSectionType<T> = T extends ThemeSection<infer R> ? Unwrap<R> : Exclude<T, ThemeSectionResolver<T>>;
interface ThemeSectionResolverContext {
    /**
     * No-op function as negated values are automatically infered and do _not_ not to be in the theme.
     */
    readonly negative: (records: Record<string, string | undefined>) => Record<string, string | undefined>;
    readonly breakpoints: (records: Record<string, ThemeScreen | undefined>) => Record<string, string | undefined>;
}
declare type ThemeSectionRecord<T = string> = Record<string, T | undefined>;
declare type ThemeSectionResolver<T = string> = (theme: ThemeResolver, context: ThemeSectionResolverContext) => ThemeSectionRecord<T>;
declare type ThemeSection<T = string> = ThemeSectionRecord<T> | ThemeSectionResolver<T>;
interface ThemeContainer {
    screens?: Record<string, string | undefined>;
    center?: boolean;
    padding?: string | Record<string, string | undefined>;
}
declare type ThemeScreenValue = string | {
    raw: string;
} | {
    min: string;
    max?: string;
} | {
    min?: string;
    max: string;
};
declare type ThemeScreen = MaybeArray<ThemeScreenValue>;
interface ThemeColorObject extends Record<string, ThemeColor> {
}
declare type ThemeColor = string | ThemeColorObject;
declare type ThemeFontSize = string | [size: string, lineHeight: string] | [size: string, options: {
    lineHeight?: string;
    letterSpacing?: string;
}];
declare type ThemeOutline = [outline: string, offset: string];
interface Theme {
    colors: ThemeSection<ThemeColor>;
    spacing: ThemeSection;
    durations: ThemeSection<string | string[]>;
    screens: ThemeSection<ThemeScreen>;
    animation: ThemeSection<string | string[]>;
    backgroundColor: ThemeSection<ThemeColor>;
    backgroundImage: ThemeSection<string | string[]>;
    backgroundOpacity: ThemeSection;
    borderColor: ThemeSection<ThemeColor>;
    borderOpacity: ThemeSection;
    borderRadius: ThemeSection;
    borderWidth: ThemeSection;
    boxShadow: ThemeSection<string | string[]>;
    container: ThemeContainer | ThemeSectionResolver<ThemeContainer>;
    divideColor: ThemeSection<ThemeColor>;
    divideOpacity: ThemeSection;
    divideWidth: ThemeSection;
    fill: ThemeSection<ThemeColor>;
    flex: ThemeSection;
    fontFamily: ThemeSection<string | string[]>;
    fontSize: ThemeSection<ThemeFontSize>;
    fontWeight: ThemeSection;
    gap: ThemeSection;
    gradientColorStops: ThemeSection<ThemeColor>;
    height: ThemeSection;
    inset: ThemeSection;
    keyframes: ThemeSection<Record<string, CSSProperties>>;
    letterSpacing: ThemeSection;
    lineHeight: ThemeSection;
    margin: ThemeSection;
    maxHeight: ThemeSection;
    maxWidth: ThemeSection;
    minHeight: ThemeSection;
    minWidth: ThemeSection;
    opacity: ThemeSection;
    order: ThemeSection;
    outline: ThemeSection<ThemeOutline>;
    padding: ThemeSection;
    placeholderColor: ThemeSection<ThemeColor>;
    placeholderOpacity: ThemeSection;
    ringColor: ThemeSection<ThemeColor>;
    ringOffsetColor: ThemeSection<ThemeColor>;
    ringOffsetWidth: ThemeSection;
    ringOpacity: ThemeSection;
    ringWidth: ThemeSection;
    rotate: ThemeSection;
    scale: ThemeSection;
    skew: ThemeSection;
    space: ThemeSection;
    stroke: ThemeSection<ThemeColor>;
    strokeWidth: ThemeSection;
    textColor: ThemeSection<ThemeColor>;
    textOpacity: ThemeSection;
    transitionDelay: ThemeSection<string | string[]>;
    transitionDuration: ThemeSection<string | string[]>;
    transitionProperty: ThemeSection<string | string[]>;
    transitionTimingFunction: ThemeSection<string | string[]>;
    translate: ThemeSection;
    width: ThemeSection;
    zIndex: ThemeSection;
}

interface Apply {
    (strings: TemplateStringsArray, ...interpolations: Token[]): Directive<CSSRules>;
    (...tokens: Token[]): Directive<CSSRules>;
}
declare const apply: Apply;

declare const tw: TW;
declare const setup: (options?: Configuration | undefined) => void;

declare const theme: ThemeHelper;

/**
 * [[include:src/css/README.md]]
 *
 * @packageDocumentation
 * @module twind/css
 */

interface CSSFactory<T, I, R> {
    (strings: TemplateStringsArray, ...interpolations: readonly MaybeThunk<MaybeArray<I | string | number | Falsy>>[]): Directive<R>;
    (tokens: MaybeThunk<MaybeArray<T | Falsy>>): Directive<R>;
    (...tokens: readonly MaybeThunk<T | Falsy>[]): Directive<R>;
}
declare const css: CSSFactory<CSSRules, CSSRules, CSSRules>;
/**
 *
 * ```js
 * const bounce = keyframes({
 *   'from, 20%, 53%, 80%, to': {
 *     transform: 'translate3d(0,0,0)',
 *   },
 *   '40%, 43%': {
 *     transform: 'translate3d(0, -30px, 0)',
 *   },
 *   '70%': {
 *     transform: 'translate3d(0, -15px, 0)',
 *   },
 *   '90%': {
 *     transform: 'translate3d(0, -4px, 0)',
 *   }
 * })
 *
 * css({
 *   animation: `${bounce} 1s ease infinite`,
 * })
 * ```
 * @param waypoints
 */
declare const keyframes: CSSFactory<CSSAtKeyframes, CSSAtKeyframes | CSSProperties, string>;
/**
 *
 * ```js
 * const bounce = animation('1s ease infinite', {
 *   'from, 20%, 53%, 80%, to': {
 *     transform: 'translate3d(0,0,0)',
 *   },
 *   '40%, 43%': {
 *     transform: 'translate3d(0, -30px, 0)',
 *   },
 *   '70%': {
 *     transform: 'translate3d(0, -15px, 0)',
 *   },
 *   '90%': {
 *     transform: 'translate3d(0, -4px, 0)',
 *   }
 * })
 * ```
 */
interface Animation {
    (value: string | CSSRules | ((context: Context) => string)): CSSFactory<CSSAtKeyframes, CSSAtKeyframes | CSSProperties, CSSRules>;
    (value: string | CSSRules | ((context: Context) => string), waypoints: CSSAtKeyframes | Directive<string>): Directive<CSSRules>;
}
declare const animation: Animation;
interface Screen {
    (size: string): Directive<string>;
    (size: string, css: Directive<CSSRules> | MaybeArray<CSSRules | Falsy>): Directive<CSSRules>;
}
declare const screen: Screen;

export { Animation, CSSFactory, Screen, animation, apply, css, keyframes, screen, setup, theme, tw };
//# sourceMappingURL=css.d.ts.map
