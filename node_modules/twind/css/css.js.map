{
  "version": 3,
  "sources": ["../../src/css/index.ts", "../../src/internal/util.ts"],
  "sourcesContent": ["/**\n * [[include:src/css/README.md]]\n *\n * @packageDocumentation\n * @module twind/css\n */\n\nimport type {\n  CSSRules,\n  CSSAtKeyframes,\n  Context,\n  CSSProperties,\n  Directive,\n  Falsy,\n  MaybeThunk,\n  MaybeArray,\n  ThemeScreenValue,\n} from '../types'\n\nimport { apply, hash, directive } from '../index'\nimport { evalThunk, merge, buildMediaQuery } from '../internal/util'\n\nexport { tw, apply, setup, theme } from '../index'\n\nexport interface CSSFactory<T, I, R> {\n  (\n    strings: TemplateStringsArray,\n    ...interpolations: readonly MaybeThunk<MaybeArray<I | string | number | Falsy>>[]\n  ): Directive<R>\n  (tokens: MaybeThunk<MaybeArray<T | Falsy>>): Directive<R>\n  (...tokens: readonly MaybeThunk<T | Falsy>[]): Directive<R>\n}\n\nconst translate = (tokens: unknown[], context: Context): CSSRules => {\n  const collect = (target: CSSRules, token: MaybeThunk<CSSRules>): CSSRules =>\n    Array.isArray(token)\n      ? token.reduce(collect, target)\n      : merge(target as CSSRules, evalThunk(token, context), context)\n\n  return (tokens as MaybeThunk<CSSRules>[]).reduce(collect, {} as CSSRules)\n}\n\n// Based on https://github.com/cristianbote/goober/blob/master/src/core/astish.js\nconst newRule = /\\s*(?:([\\w-%@]+)\\s*:?\\s*([^{;]+?)\\s*(?:;|$|})|([^;}{]*?)\\s*{)|(})/gi\nconst ruleClean = /\\/\\*[\\s\\S]*?\\*\\/|\\s+|\\n/gm\n\nconst decorate = (selectors: string[], currentBlock: CSSRules): CSSRules =>\n  selectors.reduceRight((rules, selector) => ({ [selector]: rules }), currentBlock)\n\nconst saveBlock = (\n  rules: CSSRules[],\n  selectors: string[],\n  currentBlock: CSSRules | undefined | void,\n): void => {\n  if (currentBlock) {\n    rules.push(decorate(selectors, currentBlock))\n  }\n}\n\nconst interleave = (\n  strings: TemplateStringsArray,\n  interpolations: unknown[],\n  context: Context,\n): unknown[] => {\n  let buffer = strings[0]\n  const result: unknown[] = []\n\n  for (let index = 0; index < interpolations.length; ) {\n    const interpolation = evalThunk(interpolations[index], context)\n\n    if (interpolation && typeof interpolation == 'object') {\n      result.push(buffer, interpolation)\n      buffer = strings[++index]\n    } else {\n      // Join consecutive strings\n      buffer += ((interpolation || '') as string) + strings[++index]\n    }\n  }\n\n  result.push(buffer)\n\n  return result\n}\n\nconst astish = (values: unknown[], context: Context): CSSRules[] => {\n  // Keep track of active selectors => these are the nested keys\n  const selectors: string[] = []\n  const rules: CSSRules[] = []\n\n  let currentBlock: CSSRules | undefined | void\n  let match: RegExpExecArray | null\n\n  for (let index = 0; index < values.length; index++) {\n    const value = values[index]\n\n    if (typeof value == 'string') {\n      while ((match = newRule.exec(value.replace(ruleClean, ' ')))) {\n        if (!match[0]) continue\n\n        // `}` => Save current block\n        if (match[4]) {\n          currentBlock = saveBlock(rules, selectors, currentBlock)\n          selectors.pop()\n        }\n\n        // `... {` => Start a new block\n        if (match[3]) {\n          // selector {\n          currentBlock = saveBlock(rules, selectors, currentBlock)\n          selectors.push(match[3])\n        } else if (!match[4]) {\n          if (!currentBlock) currentBlock = {}\n\n          const value = match[2] && /\\S/.test(match[2]) ? match[2] : (values[++index] as CSSRules)\n\n          if (value) {\n            if (match[1] == '@apply') {\n              merge(currentBlock, evalThunk(apply(value as string), context), context)\n            } else {\n              // a) property: value\n              currentBlock[match[1]] = value as CSSRules\n            }\n          }\n        }\n      }\n    } else {\n      currentBlock = saveBlock(rules, selectors, currentBlock)\n\n      rules.push(decorate(selectors, value as CSSRules))\n    }\n  }\n\n  saveBlock(rules, selectors, currentBlock)\n\n  return rules\n}\n\nconst cssFactory = (tokens: unknown[], context: Context): CSSRules =>\n  translate(\n    Array.isArray(tokens[0] as TemplateStringsArray) &&\n      Array.isArray((tokens[0] as TemplateStringsArray).raw)\n      ? astish(interleave(tokens[0] as TemplateStringsArray, tokens.slice(1), context), context)\n      : tokens,\n    context,\n  )\n\nexport const css: CSSFactory<CSSRules, CSSRules, CSSRules> = (\n  ...tokens: unknown[]\n): Directive<CSSRules> => directive(cssFactory, tokens)\n\nconst keyframesFactory = (tokens: unknown[], context: Context): string => {\n  const waypoints = cssFactory(tokens as CSSRules[], context)\n\n  const id = hash(JSON.stringify(waypoints))\n\n  // Inject the keyframes\n  context.tw(() => ({ [`@keyframes ${id}`]: waypoints }))\n\n  // but return the keyframe id\n  return id\n}\n\n/**\n *\n * ```js\n * const bounce = keyframes({\n *   'from, 20%, 53%, 80%, to': {\n *     transform: 'translate3d(0,0,0)',\n *   },\n *   '40%, 43%': {\n *     transform: 'translate3d(0, -30px, 0)',\n *   },\n *   '70%': {\n *     transform: 'translate3d(0, -15px, 0)',\n *   },\n *   '90%': {\n *     transform: 'translate3d(0, -4px, 0)',\n *   }\n * })\n *\n * css({\n *   animation: `${bounce} 1s ease infinite`,\n * })\n * ```\n * @param waypoints\n */\nexport const keyframes: CSSFactory<CSSAtKeyframes, CSSAtKeyframes | CSSProperties, string> = (\n  ...tokens: unknown[]\n): Directive<string> => directive(keyframesFactory, tokens)\n\n/**\n *\n * ```js\n * const bounce = animation('1s ease infinite', {\n *   'from, 20%, 53%, 80%, to': {\n *     transform: 'translate3d(0,0,0)',\n *   },\n *   '40%, 43%': {\n *     transform: 'translate3d(0, -30px, 0)',\n *   },\n *   '70%': {\n *     transform: 'translate3d(0, -15px, 0)',\n *   },\n *   '90%': {\n *     transform: 'translate3d(0, -4px, 0)',\n *   }\n * })\n * ```\n */\nexport interface Animation {\n  (value: string | CSSRules | ((context: Context) => string)): CSSFactory<\n    CSSAtKeyframes,\n    CSSAtKeyframes | CSSProperties,\n    CSSRules\n  >\n\n  (\n    value: string | CSSRules | ((context: Context) => string),\n    waypoints: CSSAtKeyframes | Directive<string>,\n  ): Directive<CSSRules>\n}\n\nexport const animation = ((\n  value: string | CSSRules | ((context: Context) => string),\n  waypoints?: CSSAtKeyframes | Directive<string>,\n): Directive<CSSRules> | CSSFactory<CSSAtKeyframes, CSSAtKeyframes | CSSProperties, CSSRules> =>\n  waypoints === undefined\n    ? (((...args: Parameters<typeof keyframes>): Directive<CSSRules> =>\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        animation(value, keyframes(...(args as any)))) as CSSFactory<\n        CSSAtKeyframes,\n        CSSAtKeyframes | CSSProperties,\n        CSSRules\n      >)\n    : css({\n        ...(value && typeof value == 'object' ? value : { animation: value }),\n        animationName: typeof waypoints == 'function' ? waypoints : keyframes(waypoints),\n      })) as Animation\n\nexport interface Screen {\n  (size: string): Directive<string>\n  (size: string, css: Directive<CSSRules> | MaybeArray<CSSRules | Falsy>): Directive<CSSRules>\n}\n\nconst screenFactory = (\n  { size, rules }: { size: string; rules?: Directive<CSSRules> | MaybeArray<CSSRules | Falsy> },\n  context: Context,\n): string | CSSRules => {\n  const media = buildMediaQuery(context.theme('screens', size) as ThemeScreenValue)\n\n  return rules === undefined\n    ? media\n    : {\n        [media]:\n          typeof rules == 'function' ? evalThunk(rules, context) : cssFactory([rules], context),\n      }\n}\n\nexport const screen = ((size: string, rules?: Directive<CSSRules> | MaybeArray<CSSRules | Falsy>) =>\n  directive(screenFactory, { size, rules })) as Screen\n", "import type {\n  Context,\n  Hasher,\n  Falsy,\n  MaybeThunk,\n  CSSRules,\n  ThemeScreen,\n  ThemeScreenValue,\n} from '../types'\n\ninterface Includes {\n  (value: string, search: string): boolean\n  <T>(value: readonly T[], search: T): boolean\n}\n\nexport const includes: Includes = (value: string | readonly unknown[], search: unknown) =>\n  // eslint-disable-next-line no-implicit-coercion\n  !!~(value as string).indexOf(search as string)\n\nexport const join = (parts: readonly string[], separator = '-'): string => parts.join(separator)\n\nexport const joinTruthy = (parts: readonly (string | Falsy)[], separator?: string): string =>\n  join(parts.filter(Boolean) as string[], separator)\n\nexport const tail = <T extends string | readonly unknown[]>(array: T, startIndex = 1): T =>\n  array.slice(startIndex) as T\n\nexport const identity = <T>(value: T): T => value\n\nexport const noop = (): void => {\n  /* no-op */\n}\n\nexport const capitalize = (value: string): string => value[0].toUpperCase() + tail(value)\n\nexport const hyphenate = (value: string): string => value.replace(/[A-Z]/g, '-$&').toLowerCase()\n\nexport const evalThunk = <T>(value: MaybeThunk<T>, context: Context): T => {\n  while (typeof value == 'function') {\n    value = (value as (context: Context) => T)(context)\n  }\n\n  return value\n}\n\nexport const ensureMaxSize = <K, V>(map: Map<K, V>, max: number): void => {\n  // Ensure the cache does not grow unlimited\n  if (map.size > max) {\n    map.delete(map.keys().next().value)\n  }\n}\n\nexport const merge = (target: CSSRules, source: CSSRules, context: Context): CSSRules =>\n  source\n    ? Object.keys(source).reduce((target, key) => {\n        const value = evalThunk(source[key], context)\n\n        if (value && typeof value == 'object' && !Array.isArray(value)) {\n          target[key] = merge((target[key] || {}) as CSSRules, value as CSSRules, context)\n        } else {\n          // hyphenate target key only if key is property like (\\w-)\n          target[hyphenate(key)] = value\n        }\n\n        return target\n      }, target)\n    : target\n\nexport const escape =\n  (typeof CSS !== 'undefined' && CSS.escape) ||\n  // Simplified: escaping only special characters\n  // Needed for NodeJS and Edge <79 (https://caniuse.com/mdn-api_css_escape)\n  ((className: string): string => {\n    const firstCodeUnit = className.charCodeAt(0)\n    let firstChar = ''\n\n    // If the character is the first character and is in the range [0-9] (2xl, ...)\n    if (firstCodeUnit >= 0x0030 && firstCodeUnit <= 0x0039) {\n      // https://drafts.csswg.org/cssom/#escape-a-character-as-code-point\n      firstChar = '\\\\' + firstCodeUnit.toString(16) + ' '\n      className = tail(className)\n    }\n\n    // Simplifed escape testing only for chars that we know happen to be in tailwind directives\n    return firstChar + className.replace(/[!./:#]/g, '\\\\$&')\n  })\n\nexport const buildMediaQuery = (screen: ThemeScreen): string => {\n  if (!Array.isArray(screen)) {\n    screen = [screen as ThemeScreenValue]\n  }\n\n  return (\n    '@media ' +\n    join(\n      (screen as ThemeScreenValue[]).map((screen) => {\n        if (typeof screen == 'string') {\n          screen = { min: screen }\n        }\n\n        return (\n          (screen as { raw?: string }).raw ||\n          join(\n            Object.keys(screen).map(\n              (feature) => `(${feature}-width:${(screen as Record<string, string>)[feature]})`,\n            ),\n            ' and ',\n          )\n        )\n      }),\n      ',',\n    )\n  )\n}\n\n// Based on https://stackoverflow.com/a/52171480\nexport const cyrb32: Hasher = (value: string): string => {\n  let h = 9\n\n  for (let index = value.length; index--; ) {\n    h = Math.imul(h ^ value.charCodeAt(index), 0x5f356495)\n  }\n\n  return 'tw-' + ((h ^ (h >>> 9)) >>> 0).toString(36)\n}\n\n/**\n * Find the array index of where to add an element to keep it sorted.\n *\n * @returns The insertion index\n */\nexport const sortedInsertionIndex = (array: readonly number[], element: number): number => {\n  let high = array.length\n\n  // Theres only one option then\n  if (high === 0) return 0\n\n  // Find position by binary search\n  for (let low = 0; low < high; ) {\n    const pivot = (high + low) >> 1\n\n    // Less-Then-Equal to add new equal element after all existing equal elements (stable sort)\n    if (array[pivot] <= element) {\n      low = pivot + 1\n    } else {\n      high = pivot\n    }\n  }\n\n  return high\n}\n"],
  "mappings": "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",
  "names": []
}
